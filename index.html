<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="天道酬勤">
<meta property="og:type" content="website">
<meta property="og:title" content="aquamarine的博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="aquamarine的博客">
<meta property="og:description" content="天道酬勤">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zsx">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>aquamarine的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">aquamarine的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description"> </p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zsx">
      <meta itemprop="description" content="天道酬勤">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aquamarine的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">《计算机网络基础》复习提纲</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-03-24 19:21:52 / Modified: 19:22:26" itemprop="dateCreated datePublished" datetime="2021-03-24T19:21:52+08:00">2021-03-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="TCP的模型，状态转移"><a href="#TCP的模型，状态转移" class="headerlink" title="TCP的模型，状态转移"></a>TCP的模型，状态转移</h2><p>四层TCP/IP模型如下：  </p>
<p>  <img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552471617097_2C832BB517B9ED772DCA7DCAD9AFBC75" alt="img">  </p>
<p>   其状态转移图如下：  </p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552471666772_F4FEF3EED170579049D40CE58E343EE4" alt="img"></p>
<h2 id="HTTP和HTTPS的区别，以及HTTPS有什么缺点？"><a href="#HTTP和HTTPS的区别，以及HTTPS有什么缺点？" class="headerlink" title="HTTP和HTTPS的区别，以及HTTPS有什么缺点？"></a>HTTP和HTTPS的区别，以及HTTPS有什么缺点？</h2><p>HTTP协议和HTTPS协议区别如下：  </p>
<p>  1）HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性 </p>
<p>  2）HTTPS在TCP三次握手阶段之后，还需要进行SSL 的handshake，协商加密使用的对称加密密钥 </p>
<p>  3）HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书 </p>
<p>  4）HTTP协议端口是80，HTTPS协议端口是443 </p>
<p>  HTTPS优点： </p>
<p>  HTTPS传输数据过程中使用密钥进行加密，所以安全性更高 </p>
<p>  HTTPS协议可以认证用户和服务器，确保数据发送到正确的用户和服务器 </p>
<p>  HTTPS缺点： </p>
<p>  HTTPS握手阶段延时较高：由于在进行HTTP会话之前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加 </p>
<p>  HTTPS部署成本高：一方面HTTPS协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高 </p>
<h2 id="HTTP返回码"><a href="#HTTP返回码" class="headerlink" title="HTTP返回码"></a>HTTP返回码</h2><p>  HTTP协议的响应报文由状态行、响应头部和响应包体组成，其响应状态码总体描述如下： </p>
<p>  1xx：指示信息–表示请求已接收，继续处理。 </p>
<p>  2xx：成功–表示请求已被成功接收、理解、接受。 </p>
<p>  3xx：重定向–要完成请求必须进行更进一步的操作。 </p>
<p>  4xx：客户端错误–请求有语法错误或请求无法实现。 </p>
<p>  5xx：服务器端错误–服务器未能实现合法的请求。 </p>
<p>  常见状态代码、状态描述的详细说明如下。 </p>
<p>  200 OK：客户端请求成功。 </p>
<p>  206 partial content服务器已经正确处理部分GET请求，实现断点续传或同时分片下载，该请求必须包含Range请求头来指示客户端期望得到的范围 </p>
<p>  300 multiple choices（可选重定向）:被请求的资源有一系列可供选择的反馈信息，由浏览器/用户自行选择其中一个。 </p>
<p>  301 moved permanently（永久重定向）：该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个URI之一。 </p>
<p>  302 move temporarily(临时重定向)：请求的资源现在临时从不同的URI中获得， </p>
<p>  304：not modified :如果客户端发送一个待条件的GET请求并且该请求以经被允许，而文档内容未被改变，则返回304,该响应不包含包体（即可直接使用缓存）。 </p>
<p>  403 Forbidden：服务器收到请求，但是拒绝提供服务。 </p>
<p>  t Found：请求资源不存在，举个例子：输入了错误的URL。 </p>
<h2 id="IP地址作用，以及MAC地址作用"><a href="#IP地址作用，以及MAC地址作用" class="headerlink" title="IP地址作用，以及MAC地址作用"></a>IP地址作用，以及MAC地址作用</h2><p>MAC地址是一个硬件地址，用来定义网络设备的位置，主要由数据链路层负责。而IP地址是IP协议提供的一种统一的地址格式，为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p>
<h2 id="OSI七层模型和TCP-IP四层模型，每层列举2个协议"><a href="#OSI七层模型和TCP-IP四层模型，每层列举2个协议" class="headerlink" title="OSI七层模型和TCP/IP四层模型，每层列举2个协议"></a>OSI七层模型和TCP/IP四层模型，每层列举2个协议</h2><p>  OSI七层模型及其包含的协议如下: </p>
<p>  物理层: 通过媒介传输比特,确定机械及电气规范,传输单位为bit，主要包括的协议为：IEE802.3 CLOCK RJ45 </p>
<p>  数据链路层: 将比特组装成帧和点到点的传递,传输单位为帧,主要包括的协议为MAC VLAN PPP </p>
<p>  网络层：负责数据包从源到宿的传递和网际互连，传输单位为包,主要包括的协议为IP ARP ICMP </p>
<p>  传输层：提供端到端的可靠报文传递和错误恢复，传输单位为报文,主要包括的协议为TCP UDP </p>
<p>  会话层：建立、管理和终止会话，传输单位为SPDU，主要包括的协议为RPC NFS </p>
<p>  表示层: 对数据进行翻译、加密和压缩,传输单位为PPDU，主要包括的协议为JPEG ASII </p>
<p>  应用层: 允许访问OSI环境的手段,传输单位为APDU，主要包括的协议为FTP HTTP DNS </p>
<p>  TCP/IP 4层模型包括： </p>
<p>  网络接口层：MAC VLAN </p>
<p>  网络层:IP ARP ICMP </p>
<p>  传输层:TCP UDP </p>
<p>  应用层:HTTP DNS SMTP </p>
<h2 id="TCP的三次握手和四次挥手的过程及原因"><a href="#TCP的三次握手和四次挥手的过程及原因" class="headerlink" title="TCP的三次握手和四次挥手的过程及原因"></a>TCP的三次握手和四次挥手的过程及原因</h2><p>  TCP的三次握手过程如下： </p>
<p>  C-&gt; SYN -&gt; S </p>
<p>  S-&gt;SYN/ACK-&gt;C </p>
<p>  C-&gt;ACK-&gt;S </p>
<p><strong>序号（seq）</strong>用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节。如果将字节流看作在两个应用程序间的单向流动，则TCP用序号对每个字节进行计数。序号是32bit的无符号数，序号到达232－1后又从0开始。</p>
<p><img src="D:\C++\图像\三次握手.JPG" alt="三次握手"></p>
<p>   三次握手的原因：三次握手可以防止已经失效的连接请求报文突然又传输到服务器端导致的服务器资源浪费。例如，客户端先发送了一个SYN，但是由于网络阻塞，该SYN数据包在某个节点长期滞留。然后客户端又重传SYN数据包并正确建立TCP连接，然后传输完数据后关闭该连接。该连接释放后失效的SYN数据包才到达服务器端。在二次握手的前提下，服务器端会认为这是客户端发起的又一次请求，然后发送SYN ，并且在服务器端创建socket套接字，一直等待客户端发送数据。但是由于客户端并没有发起新的请求，所以会丢弃服务端的SYN  。此时服务器会一直等待客户端发送数据从而造成资源浪费。 </p>
<p>  TCP的四次挥手过程如下： </p>
<p>  C-&gt;FIN-&gt;S </p>
<p>  S-&gt;ACK-&gt;C </p>
<p>  S-&gt;FIN-&gt;C </p>
<p>  C-&gt;ACK-&gt;S </p>
<p>  <img src="D:\C++\图像\四次挥手.JPG" alt="四次挥手"></p>
<p>   四次挥手的原因：其实是客户端和服务端的两次挥手，也就是客户端和服务端<strong>分别释放</strong>连接的过程。可以看到，客户端在发送完最后一次确认之后，还要<strong>等待2MSL</strong>的时间。主要有两个原因，<strong>一个</strong>是为了让B能够按照<strong>正常</strong>步骤<strong>进入CLOSED</strong>状态，<strong>二是</strong>为了防止<strong>已经失效</strong>的请求连接报文出现在下次连接中。</p>
<p>解释：</p>
<p>1）、由于<strong>客户端最后一个ACK可能会丢失</strong>，这样B就无法正常进入CLOSED状态。于是B会重传请求释放的报文，而此时A如果已经关闭了，那就收不到B的重传请求，就会<strong>导致B不能正常释放</strong>。而如果A还在等待时间内，就会收到B的重传，然后进行应答，这样B就可以进入CLOSED状态了。</p>
<p>2）、在这2MSL等待时间里面，本次连接的所有的报文都已经<strong>从网络中消失</strong>，从而不会出现在下次连接中。</p>
<h2 id="搜索baidu，会用到计算机网络中的什么层？每层是干什么的"><a href="#搜索baidu，会用到计算机网络中的什么层？每层是干什么的" class="headerlink" title="搜索baidu，会用到计算机网络中的什么层？每层是干什么的"></a>搜索baidu，会用到计算机网络中的什么层？每层是干什么的</h2><p>  浏览器中输入URL </p>
<p>   浏览器要将URL解析为IP地址，解析域名就要用到DNS协议，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。 </p>
<p>   得到IP地址后，浏览器就要与服务器建立一个http连接。因此要用到http协议，http协议报文格式上面已经提到。http生成一个get请求报文，将该报文传给TCP层处理，所以还会用到TCP协议。如果采用https还会使用https协议先对http数据进行加密。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如PPP，SLIP)，以太网协议需要直到目的IP地址的物理地址，有需要ARP协议。 </p>
<p>  其中： </p>
<p>  1、DNS协议，http协议，https协议属于应用层 </p>
<p>   应用层是体系结构中的最高层。应用层确定进程之间通信的性质以满足用户的需要。这里的进程就是指正在运行的程序。应用层不仅要提供应用进程所需要的信息交换和远地操作，而且还要作为互相作用的应用进程的用户代理，来完成一些为进行语义上有意义的信息交换所必须的功能。应用层直接为用户的应用进程提供服务。 </p>
<p>  2、TCP/UDP属于传输层 </p>
<p>  传输层的任务就是负责主机中两个进程之间的通信。因特网的传输层可使用两种不同协议：即面向连接的传输控制协议<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=TCP&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">TCP</a>，和无连接的用户数据报协议<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=UDP&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">UDP</a>。面向连接的服务能够提供可靠的交付，但无连接服务则不保证提供可靠的交付，它只是“尽最大努力交付”。这两种服务方式都很有用，备有其优缺点。在分组交换网内的各个交换结点机都没有传输层。 </p>
<p>  3、IP协议，ARP协议属于网络层 </p>
<p>  网络层负责为分组交换网上的不同主机提供通信。在发送数据时，网络层将运输层产生的报文段或用户数据报封装成分组或包进行传送。在<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=TCP&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">TCP</a>/IP体系中，分组也叫作IP数据报，或简称为数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够交付到目的主机。<br> 4、数据链路层 </p>
<p>  当发送数据时，数据链路层的任务是将在网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上传送以帧为单位的数据。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制、以及<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">流量控制</a>信息等）。控制信息使接收端能够知道—个帧从哪个比特开始和到哪个比特结束。控制信息还使接收端能够检测到所收到的帧中有无差错。<br> 5、物理层 </p>
<p>  物理层的任务就是透明地传送比特流。在物理层上所传数据的单位是比特。传递信息所利用的一些物理媒体，如<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E5%8F%8C%E7%BB%9E%E7%BA%BF&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">双绞线</a>、同轴电缆、光缆等，并不在物理层之内而是在物理层的下面。因此也有人把物理媒体当做第0层。 </p>
<h2 id="TCP拥塞控制？以及达到什么情况的时候开始减慢增长的速度？"><a href="#TCP拥塞控制？以及达到什么情况的时候开始减慢增长的速度？" class="headerlink" title="TCP拥塞控制？以及达到什么情况的时候开始减慢增长的速度？"></a>TCP拥塞控制？以及达到什么情况的时候开始减慢增长的速度？</h2><p>  拥塞控制是防止过多的数据注入网络，使得网络中的路由器或者链路过载。流量控制是点对点的通信量控制，而拥塞控制是全局的网络流量整体性的控制。发送双方都有一个拥塞窗口——cwnd。 </p>
<p>  1、慢开始 </p>
<p>  最开始发送方的拥塞窗口为1，由小到大逐渐增大发送窗口和拥塞窗口。每经过一个传输轮次，拥塞窗口cwnd加倍。当cwnd超过慢开始门限，则使用拥塞避免算法，避免cwnd增长过大。 </p>
<p>  2、拥塞避免 </p>
<p>  每经过一个往返时间RTT，cwnd就增长1。 </p>
<p>  在慢开始和拥塞避免的过程中，一旦发现网络拥塞，就把慢开始门限设为当前值的一半，并且重新设置cwnd为1，重新慢启动。（乘法减小，加法增大） </p>
<p>  3、快重传 </p>
<p>  接收方每次收到一个失序的报文段后就立即发出重复确认，发送方只要连续收到三个重复确认就立即重传（尽早重传未被确认的报文段）。 </p>
<p>  4、快恢复 </p>
<p>  当发送方连续收到了三个重复确认，就乘法减半（慢开始门限减半），将当前的cwnd设置为慢开始门限，并且采用拥塞避免算法（连续收到了三个重复请求，说明当前网络可能没有拥塞）。 </p>
<p>  采用快恢复算法时，慢开始只在建立连接和网络超时才使用。 </p>
<p>  达到什么情况的时候开始减慢增长的速度？ </p>
<p>  采用慢开始和拥塞避免算法的时候 </p>
<p>  \1. 一旦cwnd&gt;慢开始门限，就采用拥塞避免算法，减慢增长速度 </p>
<p>  \2. 一旦出现丢包的情况，就重新进行慢开始，减慢增长速度 </p>
<p>  采用快恢复和快重传算法的时候 </p>
<p>  \1. 一旦cwnd&gt;慢开始门限，就采用拥塞避免算法，减慢增长速度 </p>
<p>  \2. 一旦发送方连续收到了三个重复确认，就采用拥塞避免算法，减慢增长速度 </p>
<h2 id="TCP用了哪些措施保证其可靠性"><a href="#TCP用了哪些措施保证其可靠性" class="headerlink" title="TCP用了哪些措施保证其可靠性"></a>TCP用了哪些措施保证其可靠性</h2><p>  1、序列号、确认应答、超时重传 </p>
<p>   数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序号会说明了它下一次需要接收的数据序列号。如果发送发迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一定时间后会进行重传。这个时间一般是2*RTT(报文段往返时间）+一个偏差值。 </p>
<p>  2、窗口控制与高速重发控制/快速重传（重复确认应答） </p>
<p>  TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定要等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。 </p>
<p>   使用窗口控制，如果数据段1001-2000丢失，后面数据每次传输，确认应答都会不停地发送序号为1001的应答，表示我要接收1001开始的数据，发送端如果收到3次相同应答，就会立刻进行重发；但还有种情况有可能是数据都收到了，但是有的应答丢失了，这种情况不会进行重发，因为发送端知道，如果是数据段丢失，接收端不会放过它的，会疯狂向它提醒…… </p>
<p>  3、拥塞控制 </p>
<p>  如果把窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵（大家都在用网，你在这狂发，吞吐量就那么大，当然会堵），甚至造成网络的瘫痪。所以TCP在为了防止这种情况而进行了拥塞控制。 </p>
<p>  慢启动：定义拥塞窗口，一开始将该窗口大小设为1，之后每次收到确认应答（经过一个rtt），将拥塞窗口大小*2。 </p>
<p>  拥塞避免：设置慢启动阈值，一般开始都设为65536。拥塞避免是指当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是加法增加（每次确认应答/每个rtt，拥塞窗口大小+1），以此来避免拥塞。 </p>
<p>  将报文段的超时重传看做拥塞，则一旦发生超时重传，我们需要先将阈值设为当前窗口大小的一半，并且将窗口大小设为初值1，然后重新进入慢启动过程。 </p>
<p>  快速重传：在遇到3次重复确认应答（高速重发控制）时，代表收到了3个报文段，但是这之前的1个段丢失了，便对它进行立即重传。 </p>
<p>  然后，先将阈值设为当前窗口大小的一半，然后将拥塞窗口大小设为慢启动阈值+3的大小。 </p>
<p>  这样可以达到：在TCP通信时，网络吞吐量呈现逐渐的上升，并且随着拥堵来降低吞吐量，再进入慢慢上升的过程，网络不会轻易的发生瘫痪。 </p>
<h2 id="TCP和UDP的区别和各自适用的场景"><a href="#TCP和UDP的区别和各自适用的场景" class="headerlink" title="TCP和UDP的区别和各自适用的场景"></a>TCP和UDP的区别和各自适用的场景</h2><p>  1）TCP和UDP区别 </p>
<p>  1） 连接 </p>
<p>  TCP是面向连接的传输层协议，即传输数据之前必须先建立好连接。 </p>
<p>  UDP无连接。 </p>
<p>  2） 服务对象 </p>
<p>  TCP是点对点的两点间服务，即一条TCP连接只能有两个端点； </p>
<p>  UDP支持一对一，一对多，多对一，多对多的交互通信。 </p>
<p>  3） 可靠性 </p>
<p>  TCP是可靠交付：无差错，不丢失，不重复，按序到达。 </p>
<p>  UDP是尽最大努力交付，不保证可靠交付。 </p>
<p>  4）拥塞控制，流量控制 </p>
<p>  TCP有拥塞控制和流量控制保证数据传输的安全性。 </p>
<p>  UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。 </p>
<p>  5） 报文长度 </p>
<p>  TCP是动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。 </p>
<p>  UDP面向报文，不合并，不拆分，保留上面传下来报文的边界。 </p>
<ol start="6">
<li> 首部开销 </li>
</ol>
<p>  TCP首部开销大，首部20个字节。 </p>
<p>  UDP首部开销小，8字节。（源端口，目的端口，数据长度，校验和） </p>
<p>  2）TCP和UDP适用场景 </p>
<p>  从特点上我们已经知道，TCP 是可靠的但传输速度慢，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。 </p>
<p>  若通信数据完整性需让位与通信实时性，则应该选用TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。 </p>
<h2 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h2><p>  1）HTTP协议： </p>
<p>  HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web）服务器传输超文本到本地浏览器的传送协议。 </p>
<p>  HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件，图片文件，查询结果等）。 </p>
<p>   HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG（Next Generation of HTTP）的建议已经提出。 </p>
<p>  HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。 </p>
<p>  2）HTTP协议特点 </p>
<p>  1、简单快速： </p>
<p>  客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 </p>
<p>  2、灵活： </p>
<p>  HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 </p>
<p>  3、无连接： </p>
<p>  无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 </p>
<p>  4、无状态： </p>
<p>  HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 </p>
<p>  5、支持B/S及C/S模式。 </p>
<p>  6、默认端口80 </p>
<p>  7、基于TCP协议 </p>
<p>  3）HTTP过程概述： </p>
<p>   HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。 </p>
<p>  HTTP 请求/响应的步骤如下： </p>
<p>  1、客户端连接到Web服务器 </p>
<p>  一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a target="_blank" rel="noopener" href="http://www.baidu.com./">http://www.baidu.com。</a> </p>
<p>  2、发送HTTP请求 </p>
<p>  通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。 </p>
<p>  3、服务器接受请求并返回HTTP响应 </p>
<p>  Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。 </p>
<p>  4、释放连接TCP连接 </p>
<p>  若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求; </p>
<p>  5、客户端浏览器解析HTML内容 </p>
<p>  客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。 </p>
<p>  4、举例： </p>
<p>  在浏览器地址栏键入URL，按下回车之后会经历以下流程： </p>
<p>  1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址； </p>
<p>  2、解析出 IP 地址后，根据该 IP 地址和默认端口80，和服务器建立TCP连接； </p>
<p>  3、浏览器发出读取文件（URL中域名后面部分对应的文件）的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器； </p>
<p>  4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器； </p>
<p>  5、释放 TCP连接； </p>
<p>  6、浏览器将该 html 文本并显示内容</p>
<h2 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h2><p>  1、概括 </p>
<p>  对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； </p>
<p>  而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据） </p>
<p>  2、区别： </p>
<p>  1、get参数通过url传递，post放在request body中。 </p>
<p>  2、get请求在url中传递的参数是有长度限制的，而post没有。 </p>
<p>  3、get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。 </p>
<p>  4、get请求只能进行url编码，而post支持多种编码方式。 </p>
<p>  5、get请求会浏览器主动cache，而post支持多种编码方式。 </p>
<p>  6、get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。 </p>
<p>  7、GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 </p>
<p>  8、GET产生一个TCP数据包；POST产生两个TCP数据包。 </p>
<h2 id="socket编程中服务器端和客户端主要用到哪些函数"><a href="#socket编程中服务器端和客户端主要用到哪些函数" class="headerlink" title="socket编程中服务器端和客户端主要用到哪些函数"></a>socket编程中服务器端和客户端主要用到哪些函数</h2><p>  1）基于TCP的socket： </p>
<p>  1、服务器端程序： </p>
<p>  1创建一个socket，用函数socket() </p>
<p>  2绑定IP地址、端口等信息到socket上，用函数bind() </p>
<p>  3设置允许的最大连接数，用函数listen() </p>
<p>  4接收客户端上来的连接，用函数accept() </p>
<p>  5收发数据，用函数send()和recv()，或者read()和write() </p>
<p>  6关闭网络连接 </p>
<p>  2、客户端程序： </p>
<p>  1创建一个socket，用函数socket() </p>
<p>  2设置要连接的对方的IP地址和端口等属性 </p>
<p>  3连接服务器，用函数connect() </p>
<p>  4收发数据，用函数send()和recv()，或read()和write() </p>
<p>  5关闭网络连接 </p>
<img src="D:\C++\图像\TCP-socket.png" alt="TCP-socket"  />

<p>  2）基于UDP的socket： </p>
<p>  1、服务器端流程 </p>
<p>  1建立套接字文件描述符，使用函数socket()，生成套接字文件描述符。 </p>
<p>  2设置服务器地址和侦听端口，初始化要绑定的网络地址结构。 </p>
<p>  3绑定侦听端口，使用bind()函数，将套接字文件描述符和一个地址类型变量进行绑定。 </p>
<p>  4接收客户端的数据，使用recvfrom()函数接收客户端的网络数据。 </p>
<p>  5向客户端发送数据，使用sendto()函数向服务器主机发送数据。 </p>
<p>  6关闭套接字，使用close()函数释放资源。UDP协议的客户端流程。</p>
<p>  2、客户端流程 </p>
<p>  1建立套接字文件描述符，socket()。 </p>
<p>  2设置服务器地址和端口，struct sockaddr。 </p>
<p>  3向服务器发送数据，sendto()。 </p>
<p>  4接收服务器的数据，recvfrom()。 </p>
<p>  5关闭套接字，close()。 </p>
<p>![image-20210312134734341](C:\Users\Huawei Start\AppData\Roaming\Typora\typora-user-images\image-20210312134734341.png)</p>
<h2 id="数字证书是什么，里面都包含那些内容"><a href="#数字证书是什么，里面都包含那些内容" class="headerlink" title="数字证书是什么，里面都包含那些内容"></a>数字证书是什么，里面都包含那些内容</h2><p>  1）概念： </p>
<p>  数字证书是数字证书在一个身份和该身份的持有者所拥有的公/私钥对之间建立了一种联系，由认证中心（CA）或者认证中心的下级认证中心颁发的。根证书是认证中心与用户建立信任关系的基础。在用户使用数字证书之前必须首先下载和安装。 </p>
<p>  认证中心是一家能向用户签发数字证书以确认用户身份的管理机构。为了防止数字凭证的伪造，认证中心的公共密钥必须是可靠的，认证中心必须公布其公共密钥或由更高级别的认证中心提供一个电子凭证来证明其公共密钥的有效性，后一种方法导致了多级别认证中心的出现。 </p>
<p>  2）数字证书颁发过程： </p>
<p>   数字证书颁发过程如下：用户产生了自己的密钥对，并将公共密钥及部分个人身份信息传送给一家认证中心。认证中心在核实身份后，将执行一些必要的步骤，以确信请求确实由用户发送而来，然后，认证中心将发给用户一个数字证书，该证书内附了用户和他的密钥等信息，同时还附有对认证中心公共密钥加以确认的数字证书。当用户想证明其公开密钥的合法性时，就可以提供这一数字证书。 </p>
<p>  3）内容： </p>
<p>  数字证书的格式普遍采用的是X.509V3国际标准，一个标准的X.509数字证书包含以下一些内容： </p>
<p>  1、证书的版本信息； </p>
<p>  2、证书的序列号，每个证书都有一个唯一的证书序列号； </p>
<p>  3、证书所使用的签名算法； </p>
<p>  4、证书的发行机构名称，命名规则一般采用X.500格式； </p>
<p>  5、证书的有效期，通用的证书一般采用UTC时间格式； </p>
<p>  6、证书所有人的名称，命名规则一般采用X.500格式； </p>
<p>  7、证书所有人的公开密钥； </p>
<p>  8、证书发行者对证书的签名；</p>
<h2 id="TCP-IP数据链路层的交互过程"><a href="#TCP-IP数据链路层的交互过程" class="headerlink" title="TCP/IP数据链路层的交互过程"></a>TCP/IP数据链路层的交互过程</h2><p>   网络层等到数据链层用mac地址作为通信目标，数据包到达网络等准备往数据链层发送的时候，首先会去自己的arp缓存表(存着ip-mac对应关系)去查找改目标ip的mac地址，如果查到了，就讲目标ip的mac地址封装到链路层数据包的包头。如果缓存中没有找到，会发起一个广播：who is ip XXX tell ip  XXX,所有收到的广播的机器看这个ip是不是自己的，如果是自己的，则以单拨的形式将自己的mac地址回复给请求的机器 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zsx">
      <meta itemprop="description" content="天道酬勤">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aquamarine的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">《数据库基础与应用》复习提纲</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-15 16:41:13" itemprop="dateCreated datePublished" datetime="2021-03-15T16:41:13+08:00">2021-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-17 14:13:33" itemprop="dateModified" datetime="2021-03-17T14:13:33+08:00">2021-03-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一章：数据库发展史"><a href="#第一章：数据库发展史" class="headerlink" title="第一章：数据库发展史"></a>第一章：数据库发展史</h1><h2 id="数据库管理技术的发展"><a href="#数据库管理技术的发展" class="headerlink" title="数据库管理技术的发展"></a>数据库管理技术的发展</h2><p>1.人工管理阶段 </p>
<p>2.文件系统阶段 </p>
<p>3.倒排文件系统</p>
<p>4.数据库阶段</p>
<p>文件系统的缺陷（数据冗余性、数据不一致性、数据联系弱）。</p>
<h2 id="数据库技术的产生"><a href="#数据库技术的产生" class="headerlink" title="数据库技术的产生"></a>数据库技术的产生</h2><p>进入数据库阶段的标志是20世纪60年代末的三件大事：<br>1968年IBM公司研制的IMS系统—————–典型的层次DBS;<br>1969年美国CODASYL组织 DBTG报告提出———网状DBS的概念;<br>1970年美国IBM公司的E.F.Codd发表的论文提出—关系模型的思想</p>
<h2 id="数据库阶段的特点"><a href="#数据库阶段的特点" class="headerlink" title="数据库阶段的特点"></a>数据库阶段的特点</h2><ol>
<li> 采用数据模型表示复杂的数据结构(数据库的三级体系结构)；</li>
<li> 有较高的数据独立性(逻辑数据独立性、物理数据独立性)；</li>
<li> 数据库系统为用户提供了方便的用户接口；</li>
<li> 数据库系统提供四方面的数据控制功能：数据库的并发控制，数据库的恢复，数据的完整性，数据安全性。</li>
<li> 对数据的操作以数据项为单位，增加了系统的灵活性。</li>
</ol>
<h2 id="数据库技术的术语"><a href="#数据库技术的术语" class="headerlink" title="数据库技术的术语"></a>数据库技术的术语</h2><h2 id="数据库技术的发展"><a href="#数据库技术的发展" class="headerlink" title="数据库技术的发展"></a>数据库技术的发展</h2><h1 id="第二章：数据库系统结构"><a href="#第二章：数据库系统结构" class="headerlink" title="第二章：数据库系统结构"></a>第二章：数据库系统结构</h1><h2 id="数据描述"><a href="#数据描述" class="headerlink" title="数据描述"></a>数据描述</h2><p>从事物的特性到计算机中的具体表示，分别经历了三个阶段:<br>概念设计中的数据描述（实体、属性、实体集、实体标识符）<br>逻辑设计中的数据描述（记录、字段、文件、关键码）<br>物理设计中的数据描述（位、字节、字、块、桶、卷）</p>
<h2 id="数据联系的描述"><a href="#数据联系的描述" class="headerlink" title="数据联系的描述"></a>数据联系的描述</h2><p>联系的元数：与一个联系有关的实体集的个数<br>联系的类型： 一对一（1：1）、 一对多（1：n）、多对多（m：n）</p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p><strong>现实世界 –&gt; 概念设计 –&gt; (概念数据模型)信息世界 –&gt; 逻辑设计 –&gt; （逻辑数据模型）机器世界</strong></p>
<h3 id="概念数据模型"><a href="#概念数据模型" class="headerlink" title="概念数据模型"></a>概念数据模型</h3><p>是按用户的观点对数据建模，强调其语义表达能力。</p>
<h3 id="逻辑数据模型"><a href="#逻辑数据模型" class="headerlink" title="逻辑数据模型"></a><strong>逻辑数据模型</strong></h3><p>面向数据库逻辑结构的模型。包含：数据结构、数据操作和数据完整性约束。<br><strong>数据结构</strong>是指对实体类型和实体间联系的表达和实现；<br><strong>数据操作</strong>是指对数据库的检索和更新（包括插入、删除、修改）两类操作的实现；<br><strong>数据完整性约束</strong>给出数据及其联系应具有的制约和依赖规则。</p>
<p><strong>逻辑数据模型主要有：</strong><br><strong>层次模型：</strong>用树型结构来表示实体类型及实体之间联系的模型称为层次模型。（数据之间的联系通过指针实现）<br><strong>网状模型：</strong>用有向图结构表示实体类型及实体间联系的模型称为网状模型。（数据之间的联系通过指针实现）<br><strong>关系模型：</strong>用二维表格结构来表示实体集。(数据之间的联系 是通过外键和主键间联系实现的 即：公共属性…）<br><strong>面向对象模型：</strong>数据之间嵌套、递归联系是通过对象标识符实现的</p>
<h3 id="实体联系模型（ER模型）—一种著名概念数据模型"><a href="#实体联系模型（ER模型）—一种著名概念数据模型" class="headerlink" title="实体联系模型（ER模型）—一种著名概念数据模型"></a>实体联系模型（ER模型）—一种著名概念数据模型</h3><p> <strong>矩形框</strong>：表示实体类型;<br> <strong>菱形框</strong>：表示联系类型（实体间的联系）;<br> <strong>椭圆形框</strong>：表示实体类型和联系类型的属性;<br> <strong>用直线连接</strong>：实体与属性；联系与属性；实体与实体；</p>
<h2 id="数据库的体系结构"><a href="#数据库的体系结构" class="headerlink" title="数据库的体系结构"></a>数据库的体系结构</h2><p><strong>三级模式结构：</strong>外部级、概念级、内部级</p>
<p><strong>三级结构和两级映象：</strong>概念模式、外模式、内模式、模式/内模式映像、外模式/模式映像</p>
<p><strong>两级数据独立性:</strong>  物理数据独立性、逻辑数据独立性</p>
<p><strong>用户和用户界面</strong></p>
<h2 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h2><p>**DBMS的主要功能:**定义功能、操纵功能、保护功能、维护功能、数据字典。</p>
<p><strong>从模块结构来观察，DBMS由两大部分组成：</strong>查询处理器和存储管理器。</p>
<p>查询处理器有四个主要成分：DDL编译器，DML编译器，嵌入式DML的预编译器及查询运行核心程序。</p>
<p>存储管理器有四个主要成分：权限和完整性管理器，事务管理器，文件管理器及缓冲区管理器。</p>
<h2 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h2><p>包括数据库（DB)、硬件、软件、数据库管理员（DBA）</p>
<h1 id="第三章：关系运算"><a href="#第三章：关系运算" class="headerlink" title="第三章：关系运算"></a>第三章：关系运算</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><em><strong>关系模型：</strong></em></p>
<p>用二维表格表示实体集，用关键码表示实体间联系的数据模型；</p>
<p>*<strong>关键码： 超键、候选键、主键和外键：</strong></p>
<p>超键：用于唯一标识元组的属性或属性集</p>
<p>候选键：不含多余属性的超键</p>
<p>主键：候选键之一</p>
<p>外键：候选键之外、并作为其他关系的主键的键</p>
<p><strong>关系的定义和特点</strong></p>
<p><strong>三类完整性规则</strong></p>
<p>实体完整性规则：主键不为空。</p>
<p>参照完整性规则：外键的值要么为空、要么取其作为主键的关系里的值。</p>
<p>用户定义的完整性规则：用户自定义。</p>
<p><strong>ER模型到关系模型的转换规则；</strong></p>
<p><strong>过程性语言与非过程性语言：</strong><br> 过程性语言：编程时必须指出“干什么”及“怎么干”的语言;<br> 非过程性语言：编程时只须指出“干什么”,不必指出“怎么干” 。</p>
<h2 id="关系代数（P42-P51）"><a href="#关系代数（P42-P51）" class="headerlink" title="关系代数（P42~P51）"></a>关系代数（P42~P51）</h2><p><strong>理论基础：谓词演算</strong> </p>
<h3 id="五个基本操作（并、差、笛卡儿积、投影、选择）"><a href="#五个基本操作（并、差、笛卡儿积、投影、选择）" class="headerlink" title="五个基本操作（并、差、笛卡儿积、投影、选择）"></a>五个基本操作（并、差、笛卡儿积、投影、选择）</h3><p><strong>并：</strong>同集合并运算。</p>
<p><strong>差：</strong>R-S即属于R但不属于S组成的集合。</p>
<p><strong>笛卡尔积</strong>：R X S ，列的个数相加，行的个数相乘，元祖集合，每个元组前一项来自R，后一项来自S。</p>
<p><strong>投影：</strong>仅显示投影的列并去重。</p>
<p><strong>选择：</strong>选择出符合条件的行。</p>
<h3 id="四个组合操作（交、联接、自然联接、除）"><a href="#四个组合操作（交、联接、自然联接、除）" class="headerlink" title="四个组合操作（交、联接、自然联接、除）"></a>四个组合操作（交、联接、自然联接、除）</h3><p><strong>交：</strong>同集合交运算</p>
<p><strong>连接：</strong>笛卡尔积+选择</p>
<p><strong>自然连接：</strong>笛卡尔积+选择+列去重</p>
<p><strong>除：</strong>R中选出能匹配S中全部元组的元组，并去重（简便法）</p>
<h3 id="三个扩充的关系代数操作（外联接、外部并、半联接）；"><a href="#三个扩充的关系代数操作（外联接、外部并、半联接）；" class="headerlink" title="三个扩充的关系代数操作（外联接、外部并、半联接）；"></a>三个扩充的关系代数操作（外联接、外部并、半联接）；</h3><p>外连接：保留原该舍弃的元组，左外连接保留R该舍弃的，右外连接保留S该舍弃的。</p>
<p>外部并：属性统一为R、S的全部属性，元组全部出现，没有值的地方补空值。</p>
<p>半连接：自然连接在R或S上的投影。</p>
<h2 id="关系演算-P52-P56"><a href="#关系演算-P52-P56" class="headerlink" title="关系演算 (P52~P56)"></a>关系演算 (P52~P56)</h2><p><strong>理论基础：谓词演算 、元组关系演算和域关系演算的原子公式、公式的定义。</strong><br>无限关系（指元组个数为无穷多个的关系）；<br>无穷验证（验证公式真假时需要进行无限次验证）。<br>关系演算的安全性和等价性。</p>
<h2 id="查询优化-P57-P64"><a href="#查询优化-P57-P64" class="headerlink" title="查询优化(P57~P64)"></a>查询优化(P57~P64)</h2><ul>
<li>关系代数表达式的优化问题；</li>
<li>关系代数表达式的等价变换规则；</li>
<li>优化的策略；</li>
<li>优化算法、例 3.24</li>
</ul>
<h1 id="第四章：关系数据库语言SQL-P-67-P-97"><a href="#第四章：关系数据库语言SQL-P-67-P-97" class="headerlink" title="第四章：关系数据库语言SQL (P.67-P.97)"></a>第四章：关系数据库语言SQL (P.67-P.97)</h1><ul>
<li>SQL数据库的体系结构，SQL的组成。</li>
<li>SQL的数据定义：SQL模式、基本表和索引的创建和撤销，SQL提供的数据类型。</li>
<li>SQL的数据查询：SELECT语句的格式，单表和多表查询，基本表的联接操作，聚合和分组，集合操作。  </li>
<li>SQL的数据更新：插入、删除和修改语句。</li>
<li>视图的创建和撤消，对视图更新操作的限制。</li>
<li>嵌入式SQL：预处理方式，使用规定，使用技术。   </li>
</ul>
<h1 id="第六章：实体联系模型"><a href="#第六章：实体联系模型" class="headerlink" title="第六章：实体联系模型"></a>第六章：实体联系模型</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li><p>实体与属性的基本概念,属性的分类,联系的元数、 连通词、基数。</p>
</li>
<li><p>扩展的实体联系模型的表示方法;</p>
</li>
<li><p>如何使用实体联系模型进行概念设计的方法。</p>
</li>
</ul>
<h1 id="第七章：数据库设计"><a href="#第七章：数据库设计" class="headerlink" title="第七章：数据库设计"></a>第七章：数据库设计</h1><h2 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li><p>DBS生存期及其7个阶段的任务和工作，DBD过程的输入和输出。</p>
</li>
<li><p>需求分析的步骤、数据流图，数据字典的内容和作用。</p>
</li>
<li><p>概念设计的重要性、主要步骤。逻辑设计阶段的主要步骤。</p>
</li>
<li><p>ER模型的基本元素，属性的分类，联系的元数、连通词、基数。采用ER方法的概念设计步骤。</p>
</li>
<li><p>ER模型到关系模型的转换规则。采用ER方法的逻辑设计步骤。</p>
</li>
<li><p>ER模型的扩充：弱实体，超类和子类。</p>
</li>
<li><p>规范化理论对数据库设计的指导意义。</p>
</li>
</ul>
<h2 id="本章的重点篇幅"><a href="#本章的重点篇幅" class="headerlink" title="本章的重点篇幅"></a>本章的重点篇幅</h2><ol>
<li>教材中P163-165的转换规则和实例。</li>
<li>教材中P159-160的ER模型实例。</li>
</ol>
<h2 id="要求掌握"><a href="#要求掌握" class="headerlink" title="要求掌握"></a>要求掌握</h2><ol>
<li>基本概念、定义、方法；</li>
<li>根据用户的需求，进行ER模型设计；</li>
<li>根据转换规则，将ER模型转换为关系模型。 </li>
</ol>
<h1 id="第八章：数据库管理"><a href="#第八章：数据库管理" class="headerlink" title="第八章：数据库管理"></a>第八章：数据库管理</h1><h2 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h2><ol>
<li>事务的定义，COMMIT和ROLLBACK的语义，事务的ACID性质，事务的状态变迁图。</li>
<li>存储器类型，稳定存储器的实现，数据传送过程。</li>
<li>恢复的定义、基本原则和实现方法，故障的类型，</li>
<li>检查点机制，REDO和UNDO操作，运行记录优先原则。</li>
<li>并发操作带来的三个问题，X锁、PX协议、PXC协议，S锁、PS协议、PSC协议，活锁、饿死和死锁，并发调   度，串行调度，并发调度的可串行化，两段封锁法，SQL中事务的存取模式和隔离级别。</li>
<li>完整性的定义，完整性子系统的功能，完整性规则的组成。SQL中的三大类完整性约束，SQL3中的触发器技术。</li>
<li>安全性的定义、级别，权限，SQL中的安全性机制（视图、SQL用户权限及操作)</li>
</ol>
<h2 id="重点篇幅"><a href="#重点篇幅" class="headerlink" title="重点篇幅"></a>重点篇幅</h2><ol>
<li>检查点机制的方法和恢复算法。（教材中P.175-176）</li>
<li>并发操作带来的三个问题，封锁带来的三个问题，并发调度的可串行化。（教材P.177-179）</li>
<li>SQL中完整性约束的实现，断言、触发器(SQL3)。（教材P.185-191）</li>
<li>SQL Server 触发器的使用。（教材P.298-300） </li>
<li>安全性中的授权语句、回收语句。（教材P.193、194）</li>
</ol>
<h2 id="要求掌握-1"><a href="#要求掌握-1" class="headerlink" title="要求掌握"></a>要求掌握</h2><ol>
<li><p>恢复、并发控制、完整性和安全性的基本概念、定义和方法；</p>
</li>
<li><p>采用检测点技术进行数据恢复的分析方法；</p>
</li>
<li><p>并发调度的可串行化（包括事务的调度、串行调度、并发调度）分析方法；</p>
</li>
<li><p>根据用户的需求，能用多种方法定义完整性约束；</p>
<p>三种方法：域约束、基本表约束、断言。</p>
<p>域约束： check</p>
<p>基本表约束：primary key（属性）, foreign key (外键属性)  refference 表名（其主键）</p>
<p>断言：create assertion asser1 check (not exist( sql ))  or（10 &lt;= all (sql) ）  </p>
</li>
<li><p>授权和回收语句的使用。</p>
<p>GRANT (INSERT UPDATE SELECT DELETE REFERENCES USAGE) ON 表名 WITH GRAND OPTION</p>
<p>REVOKE (INSERT UPDATE SELECT DELETE REFERENCES USAGE) ON 表名 FROM 用户名 （CASCADE RESTRICT）</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zsx">
      <meta itemprop="description" content="天道酬勤">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aquamarine的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">《操作系统》复习提纲</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-13 20:52:42" itemprop="dateCreated datePublished" datetime="2021-03-13T20:52:42+08:00">2021-03-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-15 16:46:55" itemprop="dateModified" datetime="2021-03-15T16:46:55+08:00">2021-03-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="进程-amp-线程"><a href="#进程-amp-线程" class="headerlink" title="进程&amp;线程"></a>进程&amp;线程</h1><h2 id="进程与线程的概念"><a href="#进程与线程的概念" class="headerlink" title="进程与线程的概念"></a>进程与线程的概念</h2><p>  进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发； </p>
<p>   线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。每个线程完成不同的任务，但是共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。 </p>
<h2 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h2><p>  1.一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。 </p>
<p>   2.进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。） </p>
<p>  3.进程是资源分配的最小单位，线程是CPU调度的最小单位； </p>
<p>  4.系统开销：  由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／o设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。 </p>
<p>   5.通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预 </p>
<p>  6.进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快，但是编程调试相对复杂。 </p>
<p>  7.进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉 </p>
<p>  8.进程适应于多核、多机分布；线程适用于多核 </p>
<h2 id="线程与进程的同步"><a href="#线程与进程的同步" class="headerlink" title="线程与进程的同步"></a>线程与进程的同步</h2><p>  进程间通信的方式： </p>
<p>  进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字socket。 </p>
<p>  1.管道： </p>
<p>  管道主要包括无名管道和命名管道:管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信 </p>
<p>  1.1 普通管道PIPE： </p>
<p>  1)它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端 </p>
<p>  2)它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间） </p>
<p>  3)它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中。 </p>
<p>  1.2 命名管道FIFO： </p>
<p>  1)FIFO可以在无关的进程之间交换数据 </p>
<p>  2)FIFO有路径名与之相关联，它以一种特殊设备文件形式存在于文件系统中。 </p>
<p>2.系统IPC： </p>
<p>  2.1 消息队列 </p>
<p>   消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。  (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息； </p>
<p>  特点： </p>
<p>  1)消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。 </p>
<p>  2)消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。 </p>
<p>  3)消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。 </p>
<p>  2.2 信号量semaphore </p>
<p>  信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。 </p>
<p>  特点： </p>
<p>  1)信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。 </p>
<p>  2)信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。 </p>
<p>  3)每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。 </p>
<p>  4)支持信号量组。 </p>
<p>  2.3 信号signal </p>
<p>  信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 </p>
<p>  2.4 共享内存（Shared Memory） </p>
<p>  它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等 </p>
<p>  特点： </p>
<p>  1)共享内存是最快的一种IPC，因为进程是直接对内存进行存取 </p>
<p>  2)因为多个进程可以同时操作，所以需要进行同步 </p>
<p>  3)信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问 </p>
<p>  3.套接字SOCKET： </p>
<p>  socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。 </p>
<p>  线程间通信的方式: </p>
<p>  临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问； </p>
<p>  互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问 </p>
<p>  信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。 </p>
<p>  事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作 </p>
<h2 id="Linux虚拟地址空间-操作系统虚拟的含义"><a href="#Linux虚拟地址空间-操作系统虚拟的含义" class="headerlink" title="Linux虚拟地址空间 /操作系统虚拟的含义"></a>Linux虚拟地址空间 /操作系统虚拟的含义</h2><p>为了防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏，采用了虚拟内存。 </p>
<p>   虚拟内存技术使得不同进程在运行过程中，它所看到的是自己独自占有了当前系统的4G内存。所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。  事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text  .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。还有进程运行过程中，要动态分配内存，比如malloc时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。 </p>
<p>  请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。 </p>
<p>  虚拟内存的好处： </p>
<p>  1.扩大地址空间； </p>
<p>  2.内存保护：每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。 </p>
<p>  3.公平内存分配。采用了虚存之后，每个进程都相当于有同样大小的虚存空间。 </p>
<p>  4.当进程通信时，可采用虚存共享的方式实现。 </p>
<p>  5.当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存 </p>
<p>  6.虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。在内存中可以保留多个进程，系统并发度提高 </p>
<p>  7.在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片 </p>
<p>  虚拟内存的代价： </p>
<p>  1.虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存 </p>
<p>  2.虚拟地址到物理地址的转换，增加了指令的执行时间。 </p>
<p>  3.页面的换入换出需要磁盘I/O，这是很耗时的 </p>
<p>  4.如果一页中只有一部分数据，会浪费内存。 </p>
<h2 id="操作系统中的程序的内存结构"><a href="#操作系统中的程序的内存结构" class="headerlink" title="操作系统中的程序的内存结构"></a>操作系统中的程序的内存结构</h2><p><img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552469062814_B7994596FDDB98A22E80E1D2556A6153" alt="img"></p>
<p>   一个程序本质上都是由BSS段、data段、text段三个组成的。可以看到一个可执行程序在存储（没有调入内存）时分为代码段、数据区和未初始化数据区三部分。  </p>
<p>   BSS段（未初始化数据区）：通常用来存放程序中未初始化的全局变量和静态变量的一块内存区域。BSS段属于静态分配，程序结束后静态变量资源由系统自动释放。  </p>
<p>   数据段：存放程序中已初始化的全局变量的一块内存区域。数据段也属于静态内存分配  </p>
<p>   代码段：存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域属于只读。在代码段中，也有可能包含一些只读的常数变量  </p>
<p>   text段和data段在编译时已经分配了空间，而BSS段并不占用可执行文件的大小，它是由链接器来获取内存的。  </p>
<p>   bss段（未进行初始化的数据）的内容并不存放在磁盘上的程序文件中。其原因是内核在程序开始运行前将它们设置为0。需要存放在程序文件中的只有正文段和初始化数据段。  </p>
<p>   data段（已经初始化的数据）则为数据分配空间，数据保存到目标文件中。  </p>
<p>   数据段包含经过初始化的全局变量以及它们的值。BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段的后面。当这个内存进入程序的地址空间后全部清零。包含数据段和BSS段的整个区段此时通常称为数据区。  </p>
<p>   可执行程序在运行时又多出两个区域：栈区和堆区。  </p>
<p>​    栈区：由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中。然后这个被调用的函数再为他的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。  </p>
<p>​    堆区：用于动态分配内存，位于BSS和栈中间的地址区域。由程序员申请分配和释放。堆是从低地址位向高地址位增长，采用链式存储结构。频繁的malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要低的多。  </p>
<h2 id="操作系统中的中断"><a href="#操作系统中的中断" class="headerlink" title="操作系统中的中断"></a>操作系统中的中断</h2><p>中断是指CPU对系统发生的某个事件做出的一种反应，CPU暂停正在执行的程序，保存现场后自动去执行相应的处理程序，处理完该事件后再返回中断处继续执行原来的程序。中断一般三类，一种是由CPU外部引起的，如I/O中断、时钟中断，一种是来自CPU内部事件或程序执行中引起的中断，例如程序非法操作，地址越界、浮点溢出），最后一种是在程序中使用了系统调用引起的。而中断处理一般分为中断响应和中断处理两个步骤，中断响应由硬件实施，中断处理主要由软件实施。 </p>
<h2 id="操作系统中的缺页中断"><a href="#操作系统中的缺页中断" class="headerlink" title="操作系统中的缺页中断"></a>操作系统中的缺页中断</h2><p>malloc()和mmap()等内存分配函数，在分配时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常。 </p>
<p>  缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存是，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。 </p>
<p>  缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤： </p>
<p>  1、保护CPU现场 </p>
<p>  2、分析中断原因 </p>
<p>  3、转入缺页中断处理程序进行处理 </p>
<p>  4、恢复CPU现场，继续执行 </p>
<p>  但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别： </p>
<p>  1、在指令执行期间产生和处理缺页中断信号 </p>
<p>  2、一条指令在执行期间，可能产生多次缺页中断 </p>
<p>  3、缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令。 </p>
<h2 id="请你回答一下fork和vfork的区别"><a href="#请你回答一下fork和vfork的区别" class="headerlink" title="请你回答一下fork和vfork的区别"></a>请你回答一下fork和vfork的区别</h2><p>fork的基础知识： </p>
<p>  fork:创建一个和当前进程映像一样的进程可以通过fork( )系统调用： </p>
<p>  #include &lt;sys/types.h&gt; </p>
<p>  #include &lt;unistd.h&gt; </p>
<p>  pid_t fork(void); </p>
<p>  成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。 </p>
<p>  最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。 </p>
<p>   在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。 </p>
<p>  vfork的基础知识： </p>
<p>  在实现写时复制之前，Unix的设计者们就一直很关注在fork后立刻执行exec所造成的地址空间的浪费。BSD的开发者们在3.0的BSD系统中引入了vfork( )系统调用。 </p>
<p>  #include &lt;sys/types.h&gt; </p>
<p>  #include &lt;unistd.h&gt; </p>
<p>  pid_t vfork(void); </p>
<p>  除了子进程必须要立刻执行一次对exec的系统调用，或者调用_exit( )退出，对vfork( )的成功调用所产生的结果和fork(  )是一样的。vfork( )会挂起父进程直到子进程终止或者运行了一个新的可执行文件的映像。通过这样的方式，vfork(  )避免了地址空间的按页复制。在这个过程中，父进程和子进程共享相同的地址空间和页表项。实际上vfork(  )只完成了一件事：复制内部的内核数据结构。因此，子进程也就不能修改地址空间中的任何内存。 </p>
<p>  vfork(  )是一个历史遗留产物，Linux本不应该实现它。需要注意的是，即使增加了写时复制，vfork( )也要比fork(  )快，因为它没有进行页表项的复制。然而，写时复制的出现减少了对于替换fork( )争论。实际上，直到2.2.0内核，vfork(  )只是一个封装过的fork( )。因为对vfork( )的需求要小于fork( )，所以vfork( )的这种实现方式是可行的。 </p>
<p>  fork和vfork的区别： </p>
<ol>
<li><p>fork( )的子进程拷贝父进程的数据段和代码段；vfork( )的子进程与父进程共享数据段 </p>
</li>
<li><p>fork( )的父子进程的执行次序不确定；vfork( )保证子进程先运行，在调用exec或exit之前与父进程数据是共享的，在它调用exec或exit之后父进程才可能被调度运行。 </p>
</li>
<li><p>vfork( )保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。 </p>
</li>
<li><p>当需要改变共享数据段中变量的值，则拷贝父进程。 </p>
</li>
</ol>
<h2 id="死锁发生的条件以及如何解决死锁"><a href="#死锁发生的条件以及如何解决死锁" class="headerlink" title="死锁发生的条件以及如何解决死锁"></a>死锁发生的条件以及如何解决死锁</h2><p>死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。死锁发生的四个必要条件如下： </p>
<p>  互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源； </p>
<p>  请求和保持条件：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源 </p>
<p>  不可剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放 </p>
<p>  环路等待条件：进程发生死锁后，必然存在一个进程-资源之间的环形链 </p>
<p>  解决死锁的方法即破坏上述四个条件之一，主要方法如下： </p>
<p>  资源一次性分配，从而剥夺请求和保持条件 </p>
<p>  可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件 </p>
<p>  资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件 </p>
<h2 id="互斥锁（mutex）机制，以及互斥锁和读写锁的区别"><a href="#互斥锁（mutex）机制，以及互斥锁和读写锁的区别" class="headerlink" title="互斥锁（mutex）机制，以及互斥锁和读写锁的区别"></a>互斥锁（mutex）机制，以及互斥锁和读写锁的区别</h2><p> 1、互斥锁和读写锁区别： </p>
<p>  互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。 </p>
<p>   读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。 </p>
<p>  互斥锁和读写锁的区别： </p>
<p>  1）读写锁区分读者和写者，而互斥锁不区分 </p>
<p>  2）互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。 </p>
<p>  2、Linux的4种锁机制： </p>
<p>  互斥锁：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒 </p>
<p>   读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。  注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。 </p>
<p>   自旋锁：spinlock，在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在加锁时间短暂的环境下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源。 </p>
<p>   RCU：即read-copy-update，在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改。修改完成后，再将老数据update成新的数据。使用RCU时，读者几乎不需要同步开销，既不需要获得锁，也不使用原子指令，不会导致锁竞争，因此就不用考虑死锁问题了。而对于写者的同步开销较大，它需要复制被修改的数据，还必须使用锁机制同步并行其它写者的修改操作。在有大量读操作，少量写操作的情况下效率非常高。 </p>
<h2 id="进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞"><a href="#进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞" class="headerlink" title="进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞"></a>进程状态转换图，动态就绪，静态就绪，动态阻塞，静态阻塞</h2><p> 1、进程的五种基本状态：  </p>
<p> <img src="https://uploadfiles.nowcoder.com/images/20190313/311436_1552470678794_F9BF116BD97A95A5E655DF9E1672186F" alt="img">  </p>
<p>   1）创建状态：进程正在被创建  </p>
<p>   2）就绪状态：进程被加入到就绪队列中等待CPU调度运行  </p>
<p>   3）执行状态：进程正在被运行  </p>
<p>   4）等待阻塞状态：进程因为某种原因，比如等待I/O，等待设备，而暂时不能运行。  </p>
<p>   5）终止状态：进程运行完毕  </p>
<p>   2、交换技术  </p>
<p>   当多个进程竞争内存资源时，会造成内存资源紧张，并且，如果此时没有就绪进程，处理机会空闲，I/0速度比处理机速度慢得多，可能出现全部进程阻塞等待I/O。  </p>
<p>   针对以上问题，提出了两种解决方法：  </p>
<p>   1）交换技术：换出一部分进程到外存，腾出内存空间。  </p>
<p>   2）虚拟存储技术：每个进程只能装入一部分程序和数据。  </p>
<p>   在交换技术上，将内存暂时不能运行的进程，或者暂时不用的数据和程序，换出到外存，来腾出足够的内存空间，把已经具备运行条件的进程，或进程所需的数据和程序换入到内存。  </p>
<p>   从而出现了进程的挂起状态：进程被交换到外存，进程状态就成为了挂起状态。  </p>
<p>   3、活动阻塞，静止阻塞，活动就绪，静止就绪  </p>
<p>   1）活动阻塞：进程在内存，但是由于某种原因被阻塞了。  </p>
<p>   2）静止阻塞：进程在外存，同时被某种原因阻塞了。  </p>
<p>   3）活动就绪：进程在内存，处于就绪状态，只要给CPU和调度就可以直接运行。  </p>
<p>   4）静止就绪：进程在外存，处于就绪状态，只要调度到内存，给CPU和调度就可以运行。  </p>
<p>   从而出现了：  </p>
<p>   活动就绪 ——  静止就绪    （内存不够，调到外存）  </p>
<p>   活动阻塞 ——  静止阻塞    （内存不够，调到外存）  </p>
<p>   执行   ——  静止就绪     （时间片用完）  </p>
<h2 id="软链接和硬链接区别"><a href="#软链接和硬链接区别" class="headerlink" title="软链接和硬链接区别"></a>软链接和硬链接区别</h2><p>硬链接：inode值指向实打实的区块，删除源文件，硬链接不失效。</p>
<p>软链接：inode保存文件的绝对路径，删除原文件，软链接失效。</p>
<h2 id="静态变量什么时候初始化"><a href="#静态变量什么时候初始化" class="headerlink" title="静态变量什么时候初始化"></a>静态变量什么时候初始化</h2><p> 静态变量存储在虚拟地址空间的数据段和bss段，C语言中其在代码执行之前初始化，属于编译期初始化。而C++中由于引入对象，对象生成必须调用构造函数，因此C++规定全局或局部静态对象当且仅当对象首次用到时进行构造。</p>
<h2 id="用户态和内核态区别"><a href="#用户态和内核态区别" class="headerlink" title="用户态和内核态区别"></a>用户态和内核态区别</h2><p> 用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。</p>
<p>1）用户态切换到内核态的3种方式 </p>
<p>  1、系统调用 </p>
<p>  这是用户进程主动要求切换到内核态的一种方式，用户进程通过系统调用申请操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的ine 80h中断。 </p>
<p>  2、异常 </p>
<p>  当CPU在执行运行在用户态的程序时，发现了某些事件不可知的异常，这是会触发由当前运行进程切换到处理此。异常的内核相关程序中，也就到了内核态，比如缺页异常。 </p>
<p>  3、外围设备的中断 </p>
<p>   当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的指令，转而去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了有用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。 </p>
<p>  2）切换操作 </p>
<p>   从出发方式看，可以在认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一样的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断处理机制基本上是一样的，用户态切换到内核态的步骤主要包括： </p>
<p>  1、从当前进程的描述符中提取其内核栈的ss0及esp0信息。 </p>
<p>  2、使用ss0和esp0指向的内核栈将当前进程的cs,eip，eflags，ss,esp信息保存起来，这个过程也完成了由用户栈找到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。 </p>
<p>  3、将先前由中断向量检索得到的中断处理程序的cs，eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。 </p>
<h2 id="怎样确定当前线程是繁忙还是阻塞？"><a href="#怎样确定当前线程是繁忙还是阻塞？" class="headerlink" title="怎样确定当前线程是繁忙还是阻塞？"></a>怎样确定当前线程是繁忙还是阻塞？</h2><p> 使用ps命令查看</p>
<h2 id="内存溢出和内存泄漏"><a href="#内存溢出和内存泄漏" class="headerlink" title="内存溢出和内存泄漏"></a>内存溢出和内存泄漏</h2><p> 1、内存溢出 </p>
<p>  指程序申请内存时，没有足够的内存供申请者使用。内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误 </p>
<p>  内存溢出原因： </p>
<p>  内存中加载的数据量过于庞大，如一次从数据库取出过多数据 </p>
<p>  集合类中有对对象的引用，使用完后未清空，使得不能回收 </p>
<p>  代码中存在死循环或循环产生过多重复的对象实体 </p>
<p>  使用的第三方软件中的BUG </p>
<p>  启动参数内存值设定的过小 </p>
<p>  2、内存泄漏 </p>
<p>  内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。 </p>
<p>  内存泄漏的分类： </p>
<p>  1、堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc  new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete  删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak。 </p>
<p>  2、系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。 </p>
<p>  3、没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露</p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p> 1、概念： </p>
<p>  协程，又称微线程，纤程，英文名Coroutine。协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。 </p>
<p>  例如： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def A() :</span><br><span class="line">print &#39;1&#39;</span><br><span class="line">print &#39;2&#39;</span><br><span class="line">print &#39;3&#39;</span><br><span class="line">def B() :</span><br><span class="line">print &#39;x&#39;</span><br><span class="line">print &#39;y&#39;</span><br><span class="line">print &#39;z&#39;</span><br></pre></td></tr></table></figure>

<p>  由协程运行结果可能是12x3yz。在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A。但协程的特点在于是一个线程执行。 </p>
<p>  2）协程和线程区别 </p>
<p>  那和多线程比，协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。 </p>
<p>  第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。 </p>
<p>  3）其他 </p>
<p>  在协程上利用多核CPU呢——多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。 </p>
<p>  Python对协程的支持还非常有限，用在generator中的yield可以一定程度上实现协程。虽然支持不完全，但已经可以发挥相当大的威力了</p>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="系统调用是什么，你用过哪些系统调用"><a href="#系统调用是什么，你用过哪些系统调用" class="headerlink" title="系统调用是什么，你用过哪些系统调用"></a>系统调用是什么，你用过哪些系统调用</h2><h3 id="参考回答："><a href="#参考回答：" class="headerlink" title="参考回答："></a>参考回答：</h3><p> 1）概念： </p>
<p>  在计算机中，系统调用（英语：system call），又称为系统呼叫，指运行在使用者空间的程序向操作系统内核请求需要更高权限运行的服务。系统调用提供了用户程序与操作系统之间的接口（即系统调用是用户程序和内核交互的接口）。 </p>
<p>   操作系统中的状态分为管态（核心态）和目态（用户态）。大多数系统交互式操作需求在内核态执行。如设备IO操作或者进程间通信。特权指令：一类只能在核心态下运行而不能在用户态下运行的特殊指令。不同的操作系统特权指令会有所差异，但是一般来说主要是和硬件相关的一些指令。用户程序只在用户态下运行，有时需要访问系统核心功能，这时通过系统调用接口使用系统调用。 </p>
<p>   应用程序有时会需要一些危险的、权限很高的指令，如果把这些权限放心地交给用户程序是很危险的(比如一个进程可能修改另一个进程的内存区，导致其不能运行)，但是又不能完全不给这些权限。于是有了系统调用，危险的指令被包装成系统调用，用户程序只能调用而无权自己运行那些危险的指令。另外，计算机硬件的资源是有限的，为了更好的管理这些资源，所有的资源都由操作系统控制，进程只能向操作系统请求这些资源。操作系统是这些资源的唯一入口，这个入口就是系统调用。 </p>
<p>  2）系统调用举例： </p>
<p>  对文件进行写操作，程序向打开的文件写入字符串“hello world”，open和write都是系统调用。如下： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc&lt;<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//用读写追加方式打开一个已经存在的文件</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(argv[<span class="number">1</span>], O_RDWR | O_APPEND);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error is %s\n&quot;</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//打印文件描述符号</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;success fd = %d\n&quot;</span>, fd);</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">strcpy</span>(buf, <span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  还有写数据write，创建进程fork，vfork等都是系统调用。 </p>
<h2 id="●-请你说一下源码到可执行文件的过程"><a href="#●-请你说一下源码到可执行文件的过程" class="headerlink" title="●   请你说一下源码到可执行文件的过程"></a>●   请你说一下源码到可执行文件的过程</h2><h3 id="参考回答：-1"><a href="#参考回答：-1" class="headerlink" title="参考回答："></a>参考回答：</h3><p> 1）预编译 </p>
<p>  主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下 </p>
<p>  1、删除所有的#define，展开所有的宏定义。 </p>
<p>  2、处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。 </p>
<p>  3、处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。 </p>
<p>  4、删除所有的注释，“//”和“/**/”。 </p>
<p>  5、保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。 </p>
<p>  6、添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。 </p>
<p>  2）编译 </p>
<p>  把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。 </p>
<p>  1、词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。 </p>
<p>  2、语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。 </p>
<p>  3、语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。 </p>
<p>  4、优化：源代码级别的一个优化过程。 </p>
<p>  5、目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。 </p>
<p>  6、目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。 </p>
<p>  3）汇编 </p>
<p>  将汇编代码转变成机器可以执行的指令(机器码文件)。  汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Windows下)、xxx.obj(Linux下)。 </p>
<p>  4）链接 </p>
<p>  将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接： </p>
<p>  1、静态链接： </p>
<p>  函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。 </p>
<p>  空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本； </p>
<p>  更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。 </p>
<p>  运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。 </p>
<p>  2、动态链接： </p>
<p>  动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。 </p>
<p>  共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本； </p>
<p>  更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。 </p>
<p>  性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。 </p>
<h2 id="●-请你来说一下微内核与宏内核"><a href="#●-请你来说一下微内核与宏内核" class="headerlink" title="● 请你来说一下微内核与宏内核"></a>● 请你来说一下微内核与宏内核</h2><h3 id="参考回答：-2"><a href="#参考回答：-2" class="headerlink" title="参考回答："></a>参考回答：</h3><p> 宏内核：除了最基本的进程、线程管理、内存管理外，将文件系统，驱动，网络协议等等都集成在内核里面，例如linux内核。 </p>
<p>  优点：效率高。 </p>
<p>  缺点：稳定性差，开发过程中的bug经常会导致整个系统挂掉。 </p>
<p>  微内核：内核中只有最基本的调度、内存管理。驱动、文件系统等都是用户态的守护进程去实现的。 </p>
<p>  优点：稳定，驱动等的错误只会导致相应进程死掉，不会导致整个系统都崩溃 </p>
<p>  缺点：效率低。典型代表QNX，QNX的文件系统是跑在用户态的进程，称为resmgr的东西，是订阅发布机制，文件系统的错误只会导致这个守护进程挂掉。不过数据吞吐量就比较不乐观了。 </p>
<h2 id="请你说一下僵尸进程"><a href="#请你说一下僵尸进程" class="headerlink" title="请你说一下僵尸进程"></a>请你说一下僵尸进程</h2><p> 1）正常进程 </p>
<p>   正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。 当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。 </p>
<p>  unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息，  就可以得到：在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。 但是仍然为其保留一定的信息，直到父进程通过wait / waitpid来取时才释放。保存信息包括： </p>
<p>  1进程号the process ID </p>
<p>  2退出状态the termination status of the process </p>
<p>  3运行时间the amount of CPU time taken by the process等 </p>
<p>  2）孤儿进程 </p>
<p>  一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。 </p>
<p>  3）僵尸进程 </p>
<p>  一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。 </p>
<p>  僵尸进程是一个进程必然会经过的过程：这是每个子进程在结束时都要经过的阶段。 </p>
<p>  如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。 </p>
<p>  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。 </p>
<p>  危害： </p>
<p>  如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。 </p>
<p>  外部消灭： </p>
<p>  通过kill发送SIGTERM或者SIGKILL信号消灭产生僵尸进程的进程，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源 </p>
<p>  内部解决： </p>
<p>  1、子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。 </p>
<p>  2、fork两次，原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。 </p>
<h2 id="●-请你来介绍一下5种IO模型"><a href="#●-请你来介绍一下5种IO模型" class="headerlink" title="●   请你来介绍一下5种IO模型"></a>●   请你来介绍一下5种IO模型</h2><h3 id="参考回答：-3"><a href="#参考回答：-3" class="headerlink" title="参考回答："></a>参考回答：</h3><p> 1.阻塞IO:调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作<br> 2.非阻塞IO:非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。<br> 3.信号驱动IO:信号驱动IO:linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO时间就绪，进程收到SIGIO信号。然后处理IO事件。<br>  4.IO复用/多路转接IO:linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。知道有数据可读或可写时，才真正调用IO操作函数<br> 5.异步IO:linux中，可以调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/12/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zsx">
      <meta itemprop="description" content="天道酬勤">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="aquamarine的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/12/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-12 21:47:24" itemprop="dateCreated datePublished" datetime="2021-03-12T21:47:24+08:00">2021-03-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zsx</p>
  <div class="site-description" itemprop="description">天道酬勤</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zsx</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
